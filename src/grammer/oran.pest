// values
integer = @{ ASCII_DIGIT+ }
decimal = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT* }
ident = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
escape_char = { "\\" }
escaped_escape_char = { "\\\\" }
escaped_quote = { escape_char ~ ("'"|"\"") }
single_quote_char = { (!"'" ~ ANY)  }
double_quote_char = { (!"\"" ~ ANY)  }
string = { single_quote_string | double_quote_string }
single_quote_string = ${ "'" ~ (escaped_escape_char | escaped_quote | single_quote_char)* ~ "'" }
double_quote_string = ${ "\"" ~ (escaped_escape_char | escaped_quote | double_quote_char)* ~ "\"" }

// camparison operators
two_equals = { "==" }
bigger_than = { ">" }
smaller_than = { "<" }
e_bigger_than = { "=>" }
e_smaller_than = { "=<" }
compare = { two_equals | bigger_than | smaller_than | e_bigger_than | e_smaller_than }

// or
op_or = { "or" }
// and
op_and = { "and" } 
op_and_or = { op_or | op_and }

// calc operators
plus = { "+" }
minus = { "-" }
times = { "*" }
divide = { "/" }
modulus = { "%" }
calc = _{ plus | minus | times | divide | modulus }

// variables prefix
var_let = { "let" }
var_const = { "const" }
var_prefix = { var_let | var_const }

// White spaces and comments
WHITESPACE = _{ " " | COMMENT }
COMMENT = _{ (("//" ~ (!NEWLINE ~ ANY)*) | ("/*" ~ ( "/**/" | (!"*/" ~ ANY) )* ~ "*/")) }
IGNORED = _{ (WHITESPACE|NEWLINE) }

// variable assignment
assgmt_expr = { var_prefix ~ IGNORED* ~ ident ~ IGNORED* ~ "=" ~ IGNORED* ~ expr }
re_assgmt_expr = { ident ~ IGNORED* ~ "=" ~ IGNORED* ~ expr }

// term
element = { string | number | ident |function_call | "(" ~ calc_term ~ ")" }
calc_term = { element ~ IGNORED* ~ (calc ~ IGNORED* ~ element)+ }
number = { decimal | integer }

// string related operators
concatenated_string = !{ element ~ IGNORED* ~ ("." ~ IGNORED* ~ element)+ }

// functions
function_name = ${ (ASCII_ALPHANUMERIC | "_")+ }
function_call = ${ function_name ~ IGNORED* ~ "(" ~ IGNORED* ~ arguments_for_call ~ IGNORED* ~ ")" }
function_define = ${
    "fn" ~ IGNORED* ~ function_name ~ IGNORED* 
    ~ "(" ~ arguments_for_define ~ ")"  
    ~ IGNORED* 
    ~ "{" ~ IGNORED*
    ~ (stmt_in_function ~ IGNORED*)* ~ (fn_return|last_stmt_in_function)? 
    ~ IGNORED* ~"}"
}

// function arguments
arguments_for_call = { (operation ~ IGNORED* ~ ("," ~ IGNORED* ~ operation)*)* }
arguments_for_define = { (argument ~ IGNORED* ~ ("," ~ IGNORED* ~ argument)*)* }
argument = { (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// if 
op_if = _{ "if" }
op_else = _{ "else" }
op_else_if = _{ op_else ~ IGNORED* ~ op_if }
condition = { bool_operation ~ (IGNORED* ~ op_and_or ~ IGNORED* ~ bool_operation)* }
if_expr = ${ 
    op_if ~ IGNORED* ~ condition ~ IGNORED* ~ "{" ~ IGNORED*
    ~ (stmt_in_function ~ IGNORED*)* ~ fn_return? 
    ~ IGNORED* ~"}" 
    ~ IGNORED* ~ else_if_expr*
    ~ (IGNORED* ~ else_if_expr)*
    ~ IGNORED* ~ else_expr?
}
else_if_expr = { 
    op_else_if ~ IGNORED* ~ condition ~ IGNORED* ~ "{" ~ IGNORED*
    ~ (stmt_in_function ~ IGNORED*)* ~ fn_return? 
    ~ IGNORED* ~"}"
}
else_expr = {
    op_else ~ IGNORED* ~ "{" ~ IGNORED*
    ~ (stmt_in_function ~ IGNORED*)* ~ fn_return? 
    ~ IGNORED* ~"}"
}

// comparison
comparison = { (element|calc_term) ~ IGNORED* ~ compare ~ IGNORED* ~ (element|calc_term) }

// return
op_return = _{ "return" }
fn_return = { IGNORED* ~ op_return ~ IGNORED* ~ operation* ~ IGNORED* ~ end_mark+ }

// deliminater
end_mark = _{ ";" }

// statements and expressions
stmt = _{ expr ~ IGNORED* ~ end_mark+ | expr_without_end_mark }
last_stmt = _{ expr }
stmt_in_function = { expr_in_function ~ IGNORED* ~ end_mark+ }
last_stmt_in_function = { expr_in_function }

// expression
expr = {
    assgmt_expr
    | re_assgmt_expr
    | function_call
    | concatenated_string
    | calc_term
    | element
}
expr_without_end_mark = {
    function_define
    | if_expr
}

// expressions except assignment
operation = _{
    function_call
    | concatenated_string
    | calc_term
    | element
}

// expression that can be boolean
bool_operation = _{
    comparison
    | function_call
    | ident
}

// expressions allowed in function
expr_in_function = _{
    assgmt_expr
    | re_assgmt_expr
    | function_call
    | concatenated_string
    | calc_term
    | element
}

// program
program = _{ SOI ~ IGNORED* ~ (stmt ~ IGNORED*)* ~ last_stmt? ~ IGNORED* ~ EOI }
